/*
 * This source file was generated by the Gradle 'init' task
 */
package ru.fewizz;

import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.*;
import static org.objectweb.asm.tree.analysis.BasicValue.*;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.*;
import java.nio.file.Path;
import java.io.IOException;
import java.nio.file.Files;

public class ControlFlowObfuscator implements Opcodes {

    public static void main(String[] args) throws IOException {
        Path src = Paths.get(args[0]);
        Path dst = Paths.get(args[1]);

        // Если на вход подается путь до файла,
        // то обрабатывается только один файл
        if (!Files.isDirectory(src)) {
            handleFile(src, dst);
            return; // Выход из программы
        }

        // Рекурсивно обрабатываются все файлы в исходной директории
        Files.walk(src).forEach(srcFile -> {
            if (Files.isDirectory(srcFile))
                return;
            Path dstFile = dst.resolve(src.relativize(srcFile));
            handleFile(srcFile, dstFile);
        });
    }

    private static void handleFile(Path src, Path dst) {
         try {
            // Создание директории назначения
            Files.createDirectories(dst.getParent());

            // 1. Чтение байтов исходного класс-файла
            byte[] classFileBytes = Files.readAllBytes(src);

            // 2. Обработка класса
            classFileBytes = transform(classFileBytes);

            // 3. Запись байтов класс-файла в файл назначения
            Files.write(dst, classFileBytes);

        } catch (IOException | AnalyzerException e) {
            throw new RuntimeException(e);
        }
    }

    private static byte[] transform(byte[] classFileBytes) throws AnalyzerException {
        // Создание представления класса в виде объекта
        var classNode = new ClassNode();
        new ClassReader(classFileBytes).accept(classNode, 0);

        Interpreter<BasicValue> interpreter = new SimpleVerifier();

        // Псевдослучайный генератор случайных чисел,
        // для определения позиции свободной для обработки функции
        Random random = new Random(0);

        // Прохождение по всем методам класса
        for (MethodNode methodNode : classNode.methods) {
            // Пропускаем конструкторы, либо методы,
            // не имеющие инструкций (нативные, абстрактные и т.д.)
            if (methodNode.name.equals("<init>") || methodNode.instructions.getFirst() == null) {
                continue;
            }

            // Максимальный размер стека метода выставляется на максимальное значение,
            // позже будет перерасчитан
            methodNode.maxStack = 65535;

            // Анализируется использование стека и локальных переменных
            var analyzer = new Analyzer<>(interpreter);
            var frames = Arrays.asList(analyzer.analyze(classNode.name, methodNode));

            // Получение множества разрешенных для обработки инструкций
            Set<AbstractInsnNode> available = collectAllowedInsns(methodNode, frames);

            // Функция для случайного "вынимания" из множества
            // одной свободной инструкции
            Supplier<AbstractInsnNode> popRandomAllowedInsn = () -> {
                var allowedList = new ArrayList<>(available);
                int index = random.nextInt(allowedList.size());
                AbstractInsnNode insn = allowedList.get(index);
                available.remove(insn);
                return insn;
            };

            // Выбираются две случайные инструкции, и между ними устанавливается
            // ложная связь
            while (available.size() >= 2) {
                var src = popRandomAllowedInsn.get();
                var dst = popRandomAllowedInsn.get();
                insertFakeBranch(
                    classNode, methodNode, frames,
                    interpreter, src, dst
                );
            }
        }

        // Обратное преобразование объекта класс-файла в байты,
        // С перерсчетом максимального размера стека и фреймов
        var classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        classNode.accept(classWriter);
        classFileBytes = classWriter.toByteArray();

        return classFileBytes;
    }

    private static Set<AbstractInsnNode> collectAllowedInsns(
        MethodNode methodNode,
        List<Frame<BasicValue>> frames
    ) {
        Set<AbstractInsnNode> allowed = new HashSet<>();

        // Прохождение по всем инструкциям метода
        for (
            AbstractInsnNode insn = methodNode.instructions.getFirst();
            insn.getNext() != null;
            insn = insn.getNext()
        ) {
            if (frames.get(methodNode.instructions.indexOf(insn)) == null) {
                continue;
            }
            // Пропускаются псевдоинструкции
            if (insn instanceof LineNumberNode || insn instanceof FrameNode) {
                continue;
            }

            // Пропускается последовательность инструкций,
            // Отвечающая за создание и инициализацию объекта
            if (insn.getOpcode() == NEW) {
                insn = insn.getNext();
                if (insn == null || insn.getOpcode() != DUP) {
                    throw new RuntimeException();
                }
                insn = insn.getNext();

                while (insn.getOpcode() != INVOKESPECIAL) {
                    insn = insn.getNext();
                }
                insn = insn.getNext();
            }

            // Доабвление свободной инструкции в множество
            allowed.add(insn);
        }

        return allowed;
    }

    static void insertFakeBranch(
        ClassNode classNode, MethodNode methodNode,
        List<Frame<BasicValue>> frames,
        Interpreter<BasicValue> interpreter,
        AbstractInsnNode srcInsn,
        AbstractInsnNode dstInsn
    ) throws AnalyzerException {
        var insns = methodNode.instructions;
        Frame<BasicValue> srcFrame = frames.get(insns.indexOf(srcInsn));
        Frame<BasicValue> dstFrame = frames.get(insns.indexOf(dstInsn));

        Label fakeInsnsEndLabel = new Label();
        var fakeInsns = new InsnList();
        var fakeFrames = new ArrayList<Frame<BasicValue>>();

        final Frame<BasicValue> frame = new Frame<>(srcFrame);

        Consumer<AbstractInsnNode> addInsn = (AbstractInsnNode insn) -> {
            fakeInsns.add(insn);
            fakeFrames.add(new Frame<>(frame));
            if (insn instanceof LabelNode) {
                // Псевдо инструкция, пропускаем
            }
            else {
                try {
                    frame.execute(insn, interpreter);
                } catch (AnalyzerException e) {
                    e.printStackTrace();
                }
            }
        };

        addInsn.accept(new InsnNode(ICONST_0));
        addInsn.accept(new JumpInsnNode(IFEQ, new LabelNode(fakeInsnsEndLabel)));

        if (frame.getStackSize() != srcFrame.getStackSize()) {
            throw new RuntimeException();
        }
        // else, fake part

        for (int i = 0; i < dstFrame.getLocals(); ++i) {
            var value = dstFrame.getLocal(i);

            if (value.equals(srcFrame.getLocal(i))) {
                continue;
            }

            if (value == UNINITIALIZED_VALUE) {
                continue;
            }

            if (value == DOUBLE_VALUE) {
                addInsn.accept(new InsnNode(DCONST_0));
                addInsn.accept(new VarInsnNode(FSTORE, i));
            }
            else if (value == FLOAT_VALUE) {
                addInsn.accept(new InsnNode(FCONST_0));
                addInsn.accept(new VarInsnNode(FSTORE, i));
            }
            else if (value == LONG_VALUE) {
                addInsn.accept(new InsnNode(LCONST_0));
                addInsn.accept(new VarInsnNode(LSTORE, i));
            }
            else if (value == INT_VALUE) {
                addInsn.accept(new InsnNode(ICONST_0));
                addInsn.accept(new VarInsnNode(ISTORE, i));
            }
            else {
                addInsn.accept(new InsnNode(ACONST_NULL));
                addInsn.accept(new TypeInsnNode(CHECKCAST, value.getType().getInternalName()));
                addInsn.accept(new VarInsnNode(ASTORE, i));
            }
        }

        int diffIndex = 0;
        for (; diffIndex < srcFrame.getStackSize() && diffIndex < dstFrame.getStackSize(); ++diffIndex) {
            if (!srcFrame.getStack(diffIndex).equals(dstFrame.getStack(diffIndex))) {
                break;
            }
        }

        for (int i = srcFrame.getStackSize() - 1; i >= diffIndex ; --i) {
            var value = srcFrame.getStack(i);
            if (value == DOUBLE_VALUE || value == LONG_VALUE) {
                addInsn.accept(new InsnNode(POP2));
            }
            else {
                addInsn.accept(new InsnNode(POP));
            }
        }

        for (int i = diffIndex; i < dstFrame.getStackSize(); ++i) {
            var value = dstFrame.getStack(i);
            if (value == DOUBLE_VALUE) addInsn.accept(new InsnNode(DCONST_0));
            else if (value == FLOAT_VALUE) addInsn.accept(new InsnNode(FCONST_0));
            else if (value == LONG_VALUE) addInsn.accept(new InsnNode(LCONST_0));
            else if (value == INT_VALUE) addInsn.accept(new InsnNode(ICONST_0));
            else {
                addInsn.accept(new InsnNode(ACONST_NULL));
                addInsn.accept(new TypeInsnNode(CHECKCAST, value.getType().getInternalName()));
            }
        }

        LabelNode dstLabelInsn;

        if (dstInsn instanceof LabelNode labelNode0) {
            dstLabelInsn = labelNode0;
        }
        else {
            dstLabelInsn = new LabelNode();
            frames.add(insns.indexOf(dstInsn), new Frame<>(dstFrame));
            insns.insertBefore(dstInsn, dstLabelInsn);
        }

        addInsn.accept(new JumpInsnNode(GOTO, dstLabelInsn));

        frame.init(srcFrame);
        addInsn.accept(new LabelNode(fakeInsnsEndLabel));

        if (fakeInsns.size() != fakeFrames.size())
            throw new RuntimeException();

        frames.addAll(insns.indexOf(srcInsn), fakeFrames);
        insns.insertBefore(srcInsn, fakeInsns);

        if (insns.size() != frames.size())
            throw new RuntimeException();
    }

}
