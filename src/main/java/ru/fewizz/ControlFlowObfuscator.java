/*
 * This source file was generated by the Gradle 'init' task
 */
package ru.fewizz;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.*;
import static org.objectweb.asm.tree.analysis.BasicValue.*;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.function.Consumer;
import java.nio.file.Path;
import java.io.IOException;
import java.nio.file.Files;

public class ControlFlowObfuscator implements Opcodes {

    public static void main(String[] args) throws IOException, AnalyzerException {
        Path srcClassFilePath = Paths.get(args[0]);
        Path dstClassFilePath = Paths.get(args[1]);

        byte[] classFileBytes = Files.readAllBytes(srcClassFilePath);

        var classReader = new ClassReader(classFileBytes);
        var classNode = new ClassNode();
        classReader.accept(classNode, 0);

        Random random = new Random(0);

        for (MethodNode methodNode : classNode.methods) {
            var analyzer = new Analyzer<>(new BasicInterpreter());
            var frames = new ArrayList<Frame<BasicValue>>(
                Arrays.asList(analyzer.analyze(classNode.name, methodNode))
            );

            methodNode.maxStack = 65535; // it will be recomputed
            int count = methodNode.instructions.size() / 4;

            for (int i = 0; i < count; ++i) {
                insertFakeBranch(
                    classNode,
                    methodNode,
                    frames,
                    random.nextInt(methodNode.instructions.size()),
                    random.nextInt(methodNode.instructions.size())
                );
            }
        }

        var classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        classNode.accept(classWriter);
        classFileBytes = classWriter.toByteArray();

        Files.write(dstClassFilePath, classFileBytes);
    }

    static void insertFakeBranch(
        ClassNode classNode, MethodNode methodNode,
        ArrayList<Frame<BasicValue>> frames,
        int at, int to
    ) throws AnalyzerException {
        Frame<BasicValue> srcFrame = frames.get(at);
        Frame<BasicValue> dstFrame = frames.get(to);

        if (srcFrame == null || dstFrame == null) {
            return;
        }

        AbstractInsnNode srcInsn = methodNode.instructions.get(at);
        AbstractInsnNode dstInsn = methodNode.instructions.get(to);

        Label fakeInsnsEndLabel = new Label();
        var fakeInsns = new InsnList();
        var fakeFrames = new ArrayList<Frame<BasicValue>>();

        final Frame<BasicValue> frame = new Frame<>(srcFrame);

        Consumer<AbstractInsnNode> addInsn = (AbstractInsnNode insn) -> {
            fakeInsns.add(insn);
            fakeFrames.add(new Frame<>(frame));
            if (insn instanceof LabelNode) {
                // nothin
            }
            else {
                try {
                    frame.execute(insn, new BasicInterpreter());
                } catch (AnalyzerException e) {
                    e.printStackTrace();
                }
            }
        };

        if (srcFrame.getStackSize() == srcFrame.getMaxStackSize()) {
            return;
        }

        addInsn.accept(new InsnNode(ICONST_0));
        addInsn.accept(new JumpInsnNode(IFEQ, new LabelNode(fakeInsnsEndLabel)));

        if (frame.getStackSize() != srcFrame.getStackSize()) {
            throw new RuntimeException();
        }
        // else, fake part

        for (int i = 0; i < dstFrame.getLocals(); ++i) {
            var value = dstFrame.getLocal(i);
            if (value == REFERENCE_VALUE) {
                return;
            }

            if (dstFrame.getLocal(i) == srcFrame.getLocal(i)) {
                continue;
            }

            if (value == UNINITIALIZED_VALUE) {
                continue;
            }

            if (value == DOUBLE_VALUE) {
                addInsn.accept(new InsnNode(DCONST_0));
                addInsn.accept(new VarInsnNode(FSTORE, i));
            }
            else if (value == FLOAT_VALUE) {
                addInsn.accept(new InsnNode(FCONST_0));
                addInsn.accept(new VarInsnNode(FSTORE, i));
            }
            else if (value == LONG_VALUE) {
                addInsn.accept(new InsnNode(LCONST_0));
                addInsn.accept(new VarInsnNode(LSTORE, i));
            }
            else if (value == INT_VALUE) {
                addInsn.accept(new InsnNode(ICONST_0));
                addInsn.accept(new VarInsnNode(ISTORE, i));
            }
            else if (value == REFERENCE_VALUE) {
                throw new RuntimeException(); // impossible
            }
            else {
                throw new RuntimeException();
            }
        }

        for (int i = 0; i < dstFrame.getStackSize(); ++i) {
            var value = dstFrame.getStack(i);
            if (value == REFERENCE_VALUE) return;
        }

        int diffIndex = 0;
        for (; diffIndex < srcFrame.getStackSize() && diffIndex < dstFrame.getStackSize(); ++diffIndex) {
            if (srcFrame.getStack(diffIndex) != dstFrame.getStack(diffIndex)) {
                break;
            }
        }

        for (int i = srcFrame.getStackSize() - 1; i >= diffIndex ; --i) {
            var value = srcFrame.getStack(i);
            if (value == DOUBLE_VALUE || value == LONG_VALUE) {
                addInsn.accept(new InsnNode(POP2));
            }
            else {
                addInsn.accept(new InsnNode(POP));
            }
        }

        for (int i = diffIndex; i < dstFrame.getStackSize(); ++i) {
            var value = dstFrame.getStack(i);
            if (value == DOUBLE_VALUE) addInsn.accept(new InsnNode(DCONST_0));
            else if (value == FLOAT_VALUE) addInsn.accept(new InsnNode(FCONST_0));
            else if (value == LONG_VALUE) addInsn.accept(new InsnNode(LCONST_0));
            else if (value == INT_VALUE) addInsn.accept(new InsnNode(ICONST_0));
            else if (value == REFERENCE_VALUE) addInsn.accept(new InsnNode(ACONST_NULL));
            else throw new RuntimeException();
        }

        LabelNode dstLabelInsn;

        if (dstInsn instanceof LabelNode labelNode0) {
            dstLabelInsn = labelNode0;
        }
        else {
            dstLabelInsn = new LabelNode();
            frames.add(
                methodNode.instructions.indexOf(dstInsn),
                new Frame<>(dstFrame)
            );
            methodNode.instructions.insertBefore(dstInsn, dstLabelInsn);
        }

        addInsn.accept(new JumpInsnNode(GOTO, dstLabelInsn));

        frame.init(srcFrame);
        addInsn.accept(new LabelNode(fakeInsnsEndLabel));

        if (fakeInsns.size() != fakeFrames.size())
            throw new RuntimeException();

        frames.addAll(methodNode.instructions.indexOf(srcInsn), fakeFrames);
        methodNode.instructions.insertBefore(srcInsn, fakeInsns);

        if (methodNode.instructions.size() != frames.size())
            throw new RuntimeException();
    }

}
