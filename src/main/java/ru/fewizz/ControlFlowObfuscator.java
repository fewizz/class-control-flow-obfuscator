/*
 * This source file was generated by the Gradle 'init' task
 */
package ru.fewizz;

import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.*;
import static org.objectweb.asm.tree.analysis.BasicValue.*;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.*;
import java.nio.file.Path;
import java.io.IOException;
import java.nio.file.Files;

public class ControlFlowObfuscator implements Opcodes {

    public static void main(String[] args) throws IOException, AnalyzerException {
        Path srcClassFilePath = Paths.get(args[0]);
        Path dstClassFilePath = Paths.get(args[1]);

        byte[] classFileBytes = Files.readAllBytes(srcClassFilePath);

        var classReader = new ClassReader(classFileBytes);
        var classNode = new ClassNode();
        classReader.accept(classNode, 0);
        Interpreter<BasicValue> interpreter = new SimpleVerifier();

        Random random = new Random(0);

        for (MethodNode methodNode : classNode.methods) {
            if (methodNode.name.equals("<init>")) {
                continue;
            }
            methodNode.maxStack = 65535; // it will be recomputed

            var analyzer = new Analyzer<>(interpreter);
            var frames = new ArrayList<Frame<BasicValue>>(
                Arrays.asList(analyzer.analyze(classNode.name, methodNode))
            );
            Set<AbstractInsnNode> allowed = new HashSet<>();

            for (
                AbstractInsnNode insn = methodNode.instructions.getFirst();
                insn.getNext() != null;
                insn = insn.getNext()
            ) {
                if (frames.get(methodNode.instructions.indexOf(insn)) == null) {
                    continue;
                }

                if (insn instanceof LineNumberNode || insn instanceof FrameNode) {
                    continue;
                }

                if (insn.getOpcode() == NEW) {
                    insn = insn.getNext();

                    if (insn == null || insn.getOpcode() != DUP) {
                        throw new RuntimeException();
                    }
                    insn = insn.getNext();

                    while (insn.getOpcode() != INVOKESPECIAL) {
                        insn = insn.getNext();
                    }
                    insn = insn.getNext();
                }

                allowed.add(insn);
            }

            Supplier<AbstractInsnNode> popAllowedRandom = () -> {
                var allowedList = new ArrayList<>(allowed);
                AbstractInsnNode insn = allowedList.get(
                    random.nextInt(allowedList.size())
                );
                allowed.remove(insn);
                return insn;
            };

            while (allowed.size() >= 2) {
                var src = popAllowedRandom.get();
                var dst = popAllowedRandom.get();

                insertFakeBranch(
                    classNode,
                    methodNode,
                    frames,
                    interpreter,
                    src, dst
                );
            }
        }

        var classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        classNode.accept(classWriter);
        classFileBytes = classWriter.toByteArray();

        Files.write(dstClassFilePath, classFileBytes);
    }

    static void insertFakeBranch(
        ClassNode classNode, MethodNode methodNode,
        ArrayList<Frame<BasicValue>> frames,
        Interpreter<BasicValue> interpreter,
        AbstractInsnNode srcInsn, AbstractInsnNode dstInsn
    ) throws AnalyzerException {
        var insns = methodNode.instructions;
        Frame<BasicValue> srcFrame = frames.get(insns.indexOf(srcInsn));
        Frame<BasicValue> dstFrame = frames.get(insns.indexOf(dstInsn));

        Label fakeInsnsEndLabel = new Label();
        var fakeInsns = new InsnList();
        var fakeFrames = new ArrayList<Frame<BasicValue>>();

        final Frame<BasicValue> frame = new Frame<>(srcFrame);

        Consumer<AbstractInsnNode> addInsn = (AbstractInsnNode insn) -> {
            fakeInsns.add(insn);
            fakeFrames.add(new Frame<>(frame));
            if (insn instanceof LabelNode) {
                // nothin
            }
            else {
                try {
                    frame.execute(insn, interpreter);
                } catch (AnalyzerException e) {
                    e.printStackTrace();
                }
            }
        };

        addInsn.accept(new InsnNode(ICONST_0));
        addInsn.accept(new JumpInsnNode(IFEQ, new LabelNode(fakeInsnsEndLabel)));

        if (frame.getStackSize() != srcFrame.getStackSize()) {
            throw new RuntimeException();
        }
        // else, fake part

        for (int i = 0; i < dstFrame.getLocals(); ++i) {
            var value = dstFrame.getLocal(i);

            if (value.equals(srcFrame.getLocal(i))) {
                continue;
            }

            if (value == UNINITIALIZED_VALUE) {
                continue;
            }

            if (value == DOUBLE_VALUE) {
                addInsn.accept(new InsnNode(DCONST_0));
                addInsn.accept(new VarInsnNode(FSTORE, i));
            }
            else if (value == FLOAT_VALUE) {
                addInsn.accept(new InsnNode(FCONST_0));
                addInsn.accept(new VarInsnNode(FSTORE, i));
            }
            else if (value == LONG_VALUE) {
                addInsn.accept(new InsnNode(LCONST_0));
                addInsn.accept(new VarInsnNode(LSTORE, i));
            }
            else if (value == INT_VALUE) {
                addInsn.accept(new InsnNode(ICONST_0));
                addInsn.accept(new VarInsnNode(ISTORE, i));
            }
            else {
                addInsn.accept(new InsnNode(ACONST_NULL));
                addInsn.accept(new TypeInsnNode(CHECKCAST, value.getType().getInternalName()));
                addInsn.accept(new VarInsnNode(ASTORE, i));
            }
        }

        int diffIndex = 0;
        for (; diffIndex < srcFrame.getStackSize() && diffIndex < dstFrame.getStackSize(); ++diffIndex) {
            if (!srcFrame.getStack(diffIndex).equals(dstFrame.getStack(diffIndex))) {
                break;
            }
        }

        for (int i = srcFrame.getStackSize() - 1; i >= diffIndex ; --i) {
            var value = srcFrame.getStack(i);
            if (value == DOUBLE_VALUE || value == LONG_VALUE) {
                addInsn.accept(new InsnNode(POP2));
            }
            else {
                addInsn.accept(new InsnNode(POP));
            }
        }

        for (int i = diffIndex; i < dstFrame.getStackSize(); ++i) {
            var value = dstFrame.getStack(i);
            if (value == DOUBLE_VALUE) addInsn.accept(new InsnNode(DCONST_0));
            else if (value == FLOAT_VALUE) addInsn.accept(new InsnNode(FCONST_0));
            else if (value == LONG_VALUE) addInsn.accept(new InsnNode(LCONST_0));
            else if (value == INT_VALUE) addInsn.accept(new InsnNode(ICONST_0));
            else {
                addInsn.accept(new InsnNode(ACONST_NULL));
                addInsn.accept(new TypeInsnNode(CHECKCAST, value.getType().getInternalName()));
            }
        }

        LabelNode dstLabelInsn;

        if (dstInsn instanceof LabelNode labelNode0) {
            dstLabelInsn = labelNode0;
        }
        else {
            dstLabelInsn = new LabelNode();
            frames.add(insns.indexOf(dstInsn), new Frame<>(dstFrame));
            insns.insertBefore(dstInsn, dstLabelInsn);
        }

        addInsn.accept(new JumpInsnNode(GOTO, dstLabelInsn));

        frame.init(srcFrame);
        addInsn.accept(new LabelNode(fakeInsnsEndLabel));

        if (fakeInsns.size() != fakeFrames.size())
            throw new RuntimeException();

        frames.addAll(insns.indexOf(srcInsn), fakeFrames);
        insns.insertBefore(srcInsn, fakeInsns);

        if (insns.size() != frames.size())
            throw new RuntimeException();
    }

}
