/*
 * This source file was generated by the Gradle 'init' task
 */
package ru.fewizz;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.*;
import static org.objectweb.asm.tree.analysis.BasicValue.*;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

import java.nio.file.Path;
import java.io.IOException;
import java.nio.file.Files;

public class ControlFlowObfuscator implements Opcodes {

    public static void main(String[] args) throws IOException, AnalyzerException {
        Path srcClassFilePath = Paths.get(args[0]);
        Path dstClassFilePath = Paths.get(args[1]);

        byte[] classFileBytes = Files.readAllBytes(srcClassFilePath);

        var classReader = new ClassReader(classFileBytes);
        var classNode = new ClassNode();
        classReader.accept(classNode, 0);

        MethodNode methodNode = classNode.methods.stream()
            .filter(m -> m.name.equals("fib"))
            .findFirst().get();

        methodNode.maxStack = 65536;

        var analyzer = new Analyzer<>(new BasicInterpreter());
        var frames = new ArrayList<Frame<BasicValue>>(
            Arrays.asList(analyzer.analyze(classNode.name, methodNode))
        );

        Random random = new Random(0);

        for (int i = 0; i < 256; ++i) {
            insertFakeBranch(
                classNode,
                methodNode,
                frames,
                random.nextInt(methodNode.instructions.size()),
                random.nextInt(methodNode.instructions.size())
            );
        }

        var classWriter = new ClassWriter(
            ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS
        );
        classNode.accept(classWriter);
        classFileBytes = classWriter.toByteArray();

        Files.write(dstClassFilePath, classFileBytes);
    }

    static void insertFakeBranch(
        ClassNode classNode, MethodNode methodNode,
        ArrayList<Frame<BasicValue>> frames,
        int at, int to
    ) throws AnalyzerException {
        Frame<BasicValue> srcFrame = frames.get(at);
        Frame<BasicValue> dstFrame = frames.get(to);

        AbstractInsnNode srcInsn = methodNode.instructions.get(at);
        AbstractInsnNode dstInsn = methodNode.instructions.get(to);

        Label fakeInsnsEndLabel = new Label();
        InsnList insns = new InsnList();
        ArrayList<Frame<BasicValue>> fakeFrames = new ArrayList<>();

        Frame<BasicValue> frame = new Frame<>(srcFrame);
        fakeFrames.add(frame);

        if (srcFrame.getStackSize() == srcFrame.getMaxStackSize()) {
            return;
        }

        insns.add(new InsnNode(ICONST_0));
        frame = new Frame<>(frame);
        frame.push(INT_VALUE);
        fakeFrames.add(frame);

        insns.add(new JumpInsnNode(IFEQ, new LabelNode(fakeInsnsEndLabel)));
        frame = new Frame<>(frame);
        frame.pop();
        fakeFrames.add(frame);

        if (frame.getStackSize() != srcFrame.getStackSize()) {
            throw new RuntimeException();
        }
        // else, fake part

        for (int i = 0; i < dstFrame.getLocals(); ++i) {
            var value = dstFrame.getLocal(i);

            if (value == UNINITIALIZED_VALUE) {
                continue;
            }

            if (value == DOUBLE_VALUE) {
                /*insns.add(new InsnNode(DCONST_0));
                frame = new Frame<>(frame);
                frame.push(DOUBLE_VALUE);
                fakeFrames.add(frame);

                insns.add(new VarInsnNode(DSTORE, i));
                frame = new Frame<>(frame);
                frame.pop();
                frame.setLocal(i, DOUBLE_VALUE);
                fakeFrames.add(frame);*/
                throw new RuntimeException();
            }
            else if (value == FLOAT_VALUE) {
                insns.add(new InsnNode(FCONST_0));
                frame = new Frame<>(frame);
                frame.push(FLOAT_VALUE);
                fakeFrames.add(frame);

                insns.add(new VarInsnNode(FSTORE, i));
                frame = new Frame<>(frame);
                frame.pop();
                frame.setLocal(i, FLOAT_VALUE);
                fakeFrames.add(frame);
            }
            else if (value == LONG_VALUE) {
                /*insns.add(new InsnNode(LCONST_0));
                frame = new Frame<>(frame);
                frame.push(LONG_VALUE);
                fakeFrames.add(frame);

                insns.add(new VarInsnNode(LSTORE, i));
                frame = new Frame<>(frame);
                frame.pop();
                frame.setLocal(i, LONG_VALUE);
                fakeFrames.add(frame);*/
                throw new RuntimeException();
            }
            else if (value == INT_VALUE) {
                insns.add(new InsnNode(ICONST_0));
                frame = new Frame<>(frame);
                frame.push(INT_VALUE);
                fakeFrames.add(frame);

                insns.add(new VarInsnNode(ISTORE, i));
                frame = new Frame<>(frame);
                frame.pop();
                frame.setLocal(i, INT_VALUE);
                fakeFrames.add(frame);
            }
            else if (value == REFERENCE_VALUE) {
                insns.add(new InsnNode(ACONST_NULL));
                frame = new Frame<>(frame);
                frame.push(REFERENCE_VALUE);
                fakeFrames.add(frame);

                insns.add(new VarInsnNode(ASTORE, i));
                frame = new Frame<>(frame);
                frame.pop();
                frame.setLocal(i, REFERENCE_VALUE);
                fakeFrames.add(frame);
            }
            else {
                throw new RuntimeException();
            }
        }

        for (int i = srcFrame.getStackSize() - 1; i >= 0 ; --i) {
            var value = srcFrame.getStack(i);
            if (value == DOUBLE_VALUE || value == LONG_VALUE) {
                insns.add(new InsnNode(POP2));
            }
            else {
                insns.add(new InsnNode(POP));
            }
            frame = new Frame<>(frame);
            frame.pop();
            fakeFrames.add(frame);
        }

        for (int i = 0; i < dstFrame.getStackSize(); ++i) {
            frame = new Frame<>(frame);
            var value = dstFrame.getStack(i);
            if (value == DOUBLE_VALUE) {
                insns.add(new InsnNode(DCONST_0));
                frame.push(DOUBLE_VALUE);
            }
            else if (value == FLOAT_VALUE) {
                insns.add(new InsnNode(FCONST_0));
                frame.push(FLOAT_VALUE);
            }
            else if (value == LONG_VALUE) {
                insns.add(new InsnNode(LCONST_0));
                frame.push(LONG_VALUE);
            }
            else if (value == INT_VALUE) {
                insns.add(new InsnNode(ICONST_0));
                frame.push(INT_VALUE);
            }
            else {
                insns.add(new InsnNode(ACONST_NULL));
                frame.push(REFERENCE_VALUE);
            }
            fakeFrames.add(frame);
        }

        LabelNode dstLabelInsn;

        if (dstInsn instanceof LabelNode labelNode0) {
            dstLabelInsn = labelNode0;
        }
        else {
            dstLabelInsn = new LabelNode();
            frames.add(
                methodNode.instructions.indexOf(dstInsn),
                new Frame<>(dstFrame)
            );
            methodNode.instructions.insertBefore(dstInsn, dstLabelInsn);
        }

        insns.add(new JumpInsnNode(GOTO, dstLabelInsn));
        fakeFrames.add(new Frame<>(srcFrame));
        insns.add(new LabelNode(fakeInsnsEndLabel));

        if (insns.size() != fakeFrames.size())
            throw new RuntimeException();

        frames.addAll(methodNode.instructions.indexOf(srcInsn), fakeFrames);
        methodNode.instructions.insertBefore(srcInsn, insns);

        if (methodNode.instructions.size() != frames.size())
            throw new RuntimeException();
    }

}
